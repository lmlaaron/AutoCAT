'''
This code demonstrates how to calculate Cache Side-channel Vulnerability (CSV) index (HASP 2013).
sample cache configuration: 1-way, 8-block L1
address spaces for attacker = (8,23)
address spaces for victim = (8,15)
assume victim phase = victim's trace in v_1, v_2, v_3, ..., v_n >> vic
assume probe phase = attacker's observation trace in a_1, a_2, a_3, ..., a_n >> atk

test scenario 1: prime+probe (PP)
prime phase: the attacker made access to all blocks (16,23). not used for correlation
victim phase: the victim made only 1 access from (8,15). if access = 1, otherwise 0
probe phase : the attacker accesses all blocks (16,23), measures latency -> if $ miss = 1, $ hit = 0. only 1 block will make $ miss 

test scenario 2: flush+reload (FR)
flush phase: the attacker flushes to all blocks (8,15). not used for correlation
victim phase: the victim made only 1 access from (8,15). if access = 1, otherwise 0
reload phase: the attacker accesses all blocks (8,15), measures latency -> if $ miss = 1, $ hit = 0. only 1 block will make $ hit 

test scenario 3: evict+reload (ER)
evict phase: the attacker made access to to blocks for (16,23). not used for correlation
victim phase: the victim made only 1 access from (8,15). if access = 1, otherwise 0
reload phase: the attacker accesses all blocks (8,15), measures latency -> if $ miss = 1, $ hit = 0. only 1 block will make $ hit 
'''
import math
from scipy.stats import pearsonr

# import list for victim_trace and attacker_observation_trace
# the len of this list should be equal to block size. 
vic1 = [0,0,0,0,0,0,0,1] 
atk1 = [0,0,1,0,0,0,1,1]
vic2 = [0,0,0,0,1,0,0,0]
atk2 = [1,1,0,1,1,1,0,0]
vic3 = [0,0,1,0,0,0,0,0]
atk3 = [1,1,1,1,0,1,1,0]

mv11 = 0
mv12 = 0
mv13 = 0
mv21 = math.dist(vic2, vic1)
mv22 = 0
mv23 = 0
mv31 = math.dist(vic3, vic1)
mv32 = math.dist(vic3, vic2)
mv33 = 0

ma11 = 0
ma12 = 0
ma13 = 0
ma21 = math.dist(atk2, atk1)
ma22 = 0
ma23 = 0
ma31 = math.dist(atk3, atk1)
ma32 = math.dist(atk3, atk2)
ma33 = 0

mv = [mv11, mv12, mv13, mv21, mv22, mv23, mv31, mv32, mv33]
ma = [ma11, ma12, ma13, ma21, ma22, ma23, ma31, ma32, ma33]
 
# to calculate CSV_index:
# vic = vic1 + vic2
# atk = atk1 + atk2

class Vulnerability:
    
    def SimMatrix(): # get similarity matrix
        pass

    def SVF_index():
        corr, _ = pearsonr(mv,ma)
        print('SVF: %.3f' % corr)
    
    SVF_index()
    
    def CSV_index():
        
        corr1, _ = pearsonr(vic1, atk1)
        corr2, _ = pearsonr(vic1, atk2)
        print('CSV_PP: %.3f' % corr1)
        print('CSV_FR: %.3f' % corr2)
        
    CSV_index()
