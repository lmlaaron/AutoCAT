'''
This code demonstrates how to calculate Cache Side-channel Vulnerability (CSV) index (HASP 2013).
sample cache configuration: 1-way, 8-block L1
address spaces for attacker = (8,23)
address spaces for victim = (8,15)
assume victim phase = victim's trace in v_1, v_2, v_3, ..., v_n >> vic
assume probe phase = attacker's observation trace in a_1, a_2, a_3, ..., a_n >> atk

test scenario 1: prime+probe (PP)
prime phase: the attacker made access to all blocks (16,23). not used for correlation
victim phase: the victim made only 1 access from (8,15). if access = 1, otherwise 0
probe phase : the attacker accesses all blocks (16,23), measures latency -> if $ miss = 1, $ hit = 0. only 1 block will make $ miss 

test scenario 2: flush+reload (FR)
flush phase: the attacker flushes to all blocks (8,15). not used for correlation
victim phase: the victim made only 1 access from (8,15). if access = 1, otherwise 0
reload phase: the attacker accesses all blocks (8,15), measures latency -> if $ miss = 1, $ hit = 0. only 1 block will make $ hit 

test scenario 3: evict+reload (ER)
evict phase: the attacker made access to to blocks for (16,23). not used for correlation
victim phase: the victim made only 1 access from (8,15). if access = 1, otherwise 0
reload phase: the attacker accesses all blocks (8,15), measures latency -> if $ miss = 1, $ hit = 0. only 1 block will make $ hit 
'''
import pandas as pd
import numpy as np
import math
from scipy.stats import pearsonr

df = pd.read_csv('test.txt')
# df = df[3:7903]
#dictionary = {'(hex)':'hex'}
#df.replace(dictionary, regex=True, inplace=True)
#df = df.replace('(hex)',' ', regex=True)
#df = df.replace('access',' ', regex=True)
df.columns=['col']
#df = df['col'].str.replace("access|(hex)","")
#df = df['A'].str.replace("hex","")
#df = df[~df.col.str.contains("victim address")]
#atk = df[df.col.str.contains("hit|miss")]
#df = df[~df.col.str.contains("correct")]
df = df[~df.col.str.contains("Reset")]
atk = df[~df.col.str.contains("0x")].astype(int)
atk = atk.astype('int')
atk = np.array(atk)
atk.reshape(61,-1).T
#atk = atk.values.tolist()
print(atk)
vic = df[df.col.str.contains("0x")].astype(str)
#vic = vic.values.tolist()
#vic = vic.replace('0x8','[1,0,0,0,0,0,0,0]',regex=True)
#vic = vic.replace('0x9','[0,1,0,0,0,0,0,0]',regex=True)
#vic = vic.replace('0xa','[0,0,1,0,0,0,0,0]',regex=True)
#vic = vic.replace('0xb','[0,0,0,1,0,0,0,0]',regex=True)
#vic = vic.replace('0xc','[0,0,0,0,1,0,0,0]',regex=True)
#vic = vic.replace('0xd','[0,0,0,0,0,1,0,0]',regex=True)
#vic = vic.replace('0xe','[0,0,0,0,0,0,1,0]',regex=True)
#vic = vic.replace('0xf','[0,0,0,0,0,0,0,1]',regex=True)
#vic = vic['col'].astype(str).astype(int)
print(vic)
#vic = vic.astype(int)

#print(df)
df.to_csv('df.txt')
#print(atk)
#atk.to_csv('atk.txt', header=False, index=False)
#vic.to_csv('vic.txt', header=False, index=False)
#print(vic.dtypes)
print(vic.size)
#print(atk.dtypes)
print(atk.size)

# import list for victim_trace and attacker_observation_trace
# sample traces to check
v_1 = [0,0,0,0,0,0,0,1] # the len of this list should be equal to block size. 
v_2 = [0,0,0,0,1,0,0,0]
v_3 = [0,0,1,0,0,0,0,0]
a_1 = [0,0,1,0,0,0,1,1]
a_2 = [1,1,0,1,1,1,0,0]
a_3 = [1,1,1,1,0,1,1,0]

mv11 = 0
mv12 = 0
mv13 = 0
mv21 = math.dist(v_2, v_1)
mv22 = 0
mv23 = 0
mv31 = math.dist(v_3, v_1)
mv32 = math.dist(v_3, v_2)
mv33 = 0

ma11 = 0
ma12 = 0
ma13 = 0
ma21 = math.dist(a_2, a_1)
ma22 = 0
ma23 = 0
ma31 = math.dist(a_3, a_1)
ma32 = math.dist(a_3, a_2)
ma33 = 0

mat_v = [mv11, mv12, mv13, mv21, mv22, mv23, mv31, mv32, mv33]
mat_a = [ma11, ma12, ma13, ma21, ma22, ma23, ma31, ma32, ma33]
 
# to calculate CSV_index:
# vic = vic1 + vic2
# atk = atk1 + atk2
'''
vic_trace = []
atk_trace = []
v_n = [v0,v1,v2,v3,v_k] # k = (cache_size -1)
 
vic_trace = [v_1, v_2, v_3, v_4,...v_n] # n = 

atk_trace = [a_1,a_2,a_3,a_4,...a_n] where i=1 to n


class Vulnerability:
    
    def SimMatrix(): # get similarity matrix
        if i>j:
            mat_v=math.dist(v_i, v_j)
            mat_a=math.dist(a_i, a_j)
                
        else:
            mat_v=0
            mat_a=0
        
        mat_v = mat_v.append()
        mat_a = mat_a.append()

    def SVF_index():
        corr_svf, _ = pearsonr(mat_v,mat_a)
        print('SVF: %.2f' % corr_svf)
    
    SVF_index()
    
    def CSV_index():
        vic_trace = vic_trace.extend(v_n)
        atk_trace = atk_trace.extend(a_n)
        corr_csv, _ = pearsonr(vic_trace, atk_trace)
        print('CSV: %.2f' % corr_csv)
        
    CSV_index()
'''